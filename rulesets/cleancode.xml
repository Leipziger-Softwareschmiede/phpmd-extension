<ruleset name="Clean Code Rules Extended"
         xmlns="http://pmd.sf.net/ruleset/1.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pmd.sf.net/ruleset/1.0.0
                      http://pmd.sf.net/ruleset_xml_schema.xsd"
         xsi:noNamespaceSchemaLocation="http://pmd.sf.net/ruleset_xml_schema.xsd">
    <description>Contains rules from clean code book.</description>

    <rule name="DataStructureConstants"
          message="Don't contain constants in your data structure. Important information are distribute throughout the project. You reduce the reusability."
          class="MS\PHPMD\Rule\CleanCode\DataStructureConstants">
        <description>
            <![CDATA[
Don't contain constants in your data structure. Important information are distribute throughout the project. You reduce the reusability.
It is better to create a "Statics" namespace. Than you create final classes with your constants in this namespace.
So you can use the constants independent of your data structure.
            ]]>
        </description>
        <priority>2</priority>
        <properties>
            <property name="dataStructureNamespaceRegex" value="(((?!.*Repository).*Domain)|(?!.*Repository).*Entity)i" description="data structure regex for class namespace" />
            <property name="dataStructureCommentRegex" value="((\*\s*@isDataStructure)|(\*\s*@\S*Entity))i" description="annotation that the class is an data structure" />
        </properties>
        <example>
            <![CDATA[
// good
class Identifier
{
    const SPECIAL_ID = 1;
}

// bad
class Entity
{
    const SPECIAL_ID = 1;

    public function getAttribute()
    {
    }
}
            ]]>
        </example>
    </rule>

    <rule name="DataStructureMethods"
          message="The method should only be a simple {0} in this data structure."
          class="MS\PHPMD\Rule\CleanCode\DataStructureMethods">
        <description>
            <![CDATA[
If the class is an data structure representation, it should contain only simple getter or setter.
Otherwise you have a data object and a business object in once. Swap out the methods with business logic to a service.
If your class is an data structure, use the "@isDataStructure" annotation to force the validation.
            ]]>
        </description>
        <priority>2</priority>
        <properties>
            <property name="delimiter" value="," description="delimiter for explode" />
            <property name="prefixes" value="get,set,is,has,add,remove" description="allowed prefixes in the methods" />
            <property name="whitelist" value="__construct,__destruct,__set,__get,__call,__callStatic,__isset,__unset,__sleep,__wakeup,__toString,__invoke,__set_state,__clone" description="allowed method names" />
            <property name="dataStructureNamespaceRegex" value="(((?!.*Repository).*Domain)|(?!.*Repository).*Entity)i" description="data structure regex for class namespace" />
            <property name="dataStructureCommentRegex" value="((\*\s*@isDataStructure)|(\*\s*@\S*Entity))i" description="annotation that the class is an data structure" />
        </properties>
        <example>
            <![CDATA[
class Entity
{
    private $data;

    public function getData() // good
    {
        return $this->data;
    }

    public function setData($data) // good
    {
        $this->data = $data;

        return $this;
    }

    public function setData($data) // bad
    {
        $this->data = $data;
        $this->doSomething();
    }

    public function doSomthing() // bad
    {
        foreach ($this->data as $data) {
            calculate($data);
        }
    }
}
            ]]>
        </example>
    </rule>
</ruleset>
