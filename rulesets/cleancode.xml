<ruleset name="Clean Code Rules Extended"
         xmlns="http://pmd.sf.net/ruleset/1.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pmd.sf.net/ruleset/1.0.0
                      http://pmd.sf.net/ruleset_xml_schema.xsd"
         xsi:noNamespaceSchemaLocation="http://pmd.sf.net/ruleset_xml_schema.xsd">
    <description>Contains rules from clean code book. This includes rules from SOLID.</description>

    <rule name="DataStructureConstants"
          message="Don't contain constants in your data structure. Important information are distribute throughout the project. You reduce the reusability."
          class="MS\PHPMD\Rule\CleanCode\DataStructureConstants">
        <description>
            <![CDATA[
Don't contain constants in your data structure. Important information are distribute throughout the project. You reduce the reusability.
It is better to create a "Statics" namespace. Than you create final classes with your constants in this namespace.
So you can use the constants independent of your data structure.
            ]]>
        </description>
        <priority>2</priority>
        <properties>
            <property name="dataStructureNamespaceRegex" value="(((?!.*Repository).*Domain)|(?!.*Repository).*Entity)i" description="data structure regex for class namespace" />
            <property name="dataStructureCommentRegex" value="((\*\s*@isDataStructure)|(\*\s*@\S*Entity))i" description="annotation that the class is an data structure" />
        </properties>
        <example>
            <![CDATA[
// good
class Identifier
{
    const SPECIAL_ID = 1;
}

// bad
class Entity
{
    const SPECIAL_ID = 1;

    public function getAttribute()
    {
    }
}
            ]]>
        </example>
    </rule>

    <rule name="DataStructureMethods"
          message="The method should only be a simple {0} in this data structure."
          class="MS\PHPMD\Rule\CleanCode\DataStructureMethods">
        <description>
            <![CDATA[
If the class is an data structure representation, it should contain only simple getter or setter.
Otherwise you have a data object and a business object in once. Swap out the methods with business logic to a service.
If your class is an data structure, use the "@isDataStructure" annotation to force the validation.
            ]]>
        </description>
        <priority>2</priority>
        <properties>
            <property name="delimiter" value="," description="delimiter for explode" />
            <property name="prefixes" value="get,set,is,has,add,remove" description="allowed prefixes in the methods" />
            <property name="whitelist" value="__construct,__destruct,__set,__get,__call,__callStatic,__isset,__unset,__sleep,__wakeup,__toString,__invoke,__set_state,__clone" description="allowed method names" />
            <property name="dataStructureNamespaceRegex" value="(((?!.*Repository).*Domain)|(?!.*Repository).*Entity)i" description="data structure regex for class namespace" />
            <property name="dataStructureCommentRegex" value="((\*\s*@isDataStructure)|(\*\s*@\S*Entity))i" description="annotation that the class is an data structure" />
        </properties>
        <example>
            <![CDATA[
class Entity
{
    private $data;

    public function getData() // good
    {
        return $this->data;
    }

    public function setData($data) // good
    {
        $this->data = $data;

        return $this;
    }

    public function setData($data) // bad
    {
        $this->data = $data;
        $this->doSomething();
    }

    public function doSomthing() // bad
    {
        foreach ($this->data as $data) {
            calculate($data);
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MemberPrimaryPrefix"
          message="Don't chain methods excessively. There are {0} concatenations allowed. The code becomes hard to test and violate the law of demeter."
          class="MS\PHPMD\Rule\CleanCode\MemberPrimaryPrefix">
        <description>
            <![CDATA[
Try to avoid train wrecks. Your class should have a low coupling. You have to use mocks excessively when you deep link to subclasses.
Create a a wrapper method in your related class and delegate the access. You can avoid code duplications. See law of demeter.
            ]]>
        </description>
        <priority>2</priority>
        <properties>
            <property name="maxChainCount" value="2" description="max count of method chains" />
        </properties>
        <example>
            <![CDATA[
class Entry
{
    public function getName()
    {
        return $this->name;
    }
}

class Relation
{
    public function getEntry()
    {
        return $this->entry;
    }

    public function getEntryName()
    {
        return $this->entry->getName();
    }
}

class Service
{
    public function doSomething()
    {
        $name = $this->relation->getEntry()->getName(); // bad
        $name = $this->relation->getEntryName(); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="ReturnStatement"
          message="A return statement line should only contains {0}. It increase the reading rate."
          class="MS\PHPMD\Rule\CleanCode\ReturnStatement">
        <description>
            <![CDATA[
Don't write your logical code in the return statement line. It is hard to understand. Move the complex structure ahead.
It increase the reading rate. Then you can extend the code easily without touching the return statement.
            ]]>
        </description>
        <priority>3</priority>
        <properties>
            <property name="delimiter" value="," description="delimiter for explode" />
            <property name="allowedChildren" value="Variable,MemberPrimaryPrefix,Literal,FunctionPostfix,Array" description="allowed children" />
        </properties>
        <example>
            <![CDATA[
class Returner
{
    public function getType() // good
    {
        return $variable;
    }

    public function getType() // good
    {
        return $this->getVariable();
    }

    public function getType() // bad
    {
        return 1 === 1 ? '1' : 2;
    }

    public function getType() // bad
    {
        return $this->doSomething() && !$this->doAnything();
    }

    public function getType() // bad
    {
        return 1 > count($this->doSomething());
    }
}
            ]]>
        </example>
    </rule>
</ruleset>
