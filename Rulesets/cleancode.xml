<ruleset name="cleancode"
         xmlns="http://pmd.sf.net/ruleset/1.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pmd.sf.net/ruleset/1.0.0
                      http://pmd.sf.net/ruleset_xml_schema.xsd"
         xsi:noNamespaceSchemaLocation="http://pmd.sf.net/ruleset_xml_schema.xsd">
    <description>Contains specific clean code rules for the Symfony2 framework.</description>

    <rule name="ClassNameSingleResponsibility"
          message="Try to avoid general suffixes like {0} found {1}. It might violate of the single responsibility principle."
          class="MS\PHPMD\Rule\CleanCode\ClassNameSingleResponsibility"
          externalInfoUrl="http://stackoverflow.com/questions/1866794/naming-classes-how-to-avoid-calling-everything-a-whatevermanager">
        <description>
            <![CDATA[
Yeah you are on the right track. There is no business logic in the entities and the controllers are slim.
Oh dear. Now you have classes like UserManager or PageHandler. But what do this classes?
You might violate of the single responsibility principle. Split the Manager class. What do the methods?
Can you use the event dispatcher pattern? No? Maybe better general suffixes are Builder, Writer, Reader, Converter.
            ]]>
        </description>
        <priority>5</priority>
        <properties>
            <property name="delimiter" value="," description="delimiter for explode" />
            <property name="suffixes" value="Manager,Handler,Helper,Util,Information,Processor" description="bad general suffixes" />
        </properties>
        <example>
            <![CDATA[
class FooManager // bad
{
    public function doSomething()
    {
    }

    public function doCompletelyOtherThings()
    {
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MethodOneTryCatch"
          message="This method contains more than one try statement. Swap out the try statement in an extra method. It increase the readability."
          class="MS\PHPMD\Rule\CleanCode\MethodOneTryCatch">
        <description>
            <![CDATA[
A method should be a wrapper for a try statement. It increase the readability. Try to find a good name for the method.
            ]]>
        </description>
        <priority>2</priority>
        <properties>
            <property name="delimiter" value="," description="delimiter for explode" />
            <property name="allowedChildren" value="catch,finally" description="allowed children" />
        </properties>
        <example>
            <![CDATA[
class TryThings
{
    public function tryToDoSomething() // good
    {
        try {
            $this->doSomething();
        } catch () {
        }
    }

    public function doSomething() // bad
    {
        $this->work();

        try {
            $this->doSomething();
        } catch () {
        }

        try {
            $this->doSomething();
        } catch () {
        }

        if (1 === 1) {
            foreach ($data as $item) {
                $this->doMore();
            }
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="SuperfluousComment"
          message="It seems that the {0} has a superfluous comment description. It fits {1} percent with the name of that."
          class="MS\PHPMD\Rule\CleanCode\SuperfluousComment">
        <description>
            <![CDATA[
Comments should be considered thoroughly in advance. Don't comment bad code. Rewrite it.
Also try to avoid superfluous comments. It is obvious that getName returns a name.
It is normal that you maintenance your code but not your comments. So the comment will mislead you later on.
Comments who describe why you write this code are good comments.
            ]]>
        </description>
        <priority>2</priority>
        <properties>
            <property name="percent" value="60" description="allowed name-to-comment similarity in percent" />
        </properties>
        <example>
            <![CDATA[
class SuperfluousComment
{
    /**
     * @var string
     *
     * the name
     */
    private $name;

    /**
     * get name
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * set name
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }

    /**
     * @param string $value
     */
    public function doSomething($value)
    {
    }
}
            ]]>
        </example>
    </rule>

</ruleset>
